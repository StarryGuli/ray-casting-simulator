<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ray Casting Simulator</title>
    <style>
        :root {
            --primary: #3b82f6;
            --bg: #f3f4f6;
            --card-bg: #ffffff;
            --text-main: #1f2937;
            --text-sub: #6b7280;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            touch-action: pan-y; /* å…è®¸å‚ç›´æ»šåŠ¨ï¼Œä½†åœ¨canvasä¸Šä¼šæ‹¦æˆª */
        }

        /* é¡¶éƒ¨å¯¼èˆªæ  */
        .navbar {
            width: 100%;
            padding: 15px 20px;
            background: var(--card-bg);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 1.2rem;
            font-weight: 700;
        }

        /* è¯­è¨€åˆ‡æ¢æŒ‰é’® */
        .lang-btn {
            background: transparent;
            border: 1px solid #e5e7eb;
            padding: 6px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .lang-btn:hover {
            background: #f9fafb;
            border-color: #d1d5db;
        }

        /* ä¸»å®¹å™¨ */
        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 600px;
            padding: 20px;
            box-sizing: border-box;
        }

        /* ç”»å¸ƒå®¹å™¨ */
        .canvas-wrapper {
            position: relative;
            width: 100%;
            /* ä¿æŒæ­£æ–¹å½¢æ¯”ä¾‹ */
            aspect-ratio: 1 / 1; 
            max-width: 500px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            margin-bottom: 20px;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: move;
            touch-action: none; /* ç¦æ­¢Canvasä¸Šçš„æµè§ˆå™¨é»˜è®¤è§¦æ‘¸è¡Œä¸º */
        }

        /* æ§åˆ¶é¢æ¿ */
        .controls {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 12px;
            width: 100%;
            max-width: 500px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        label {
            font-weight: 600;
            min-width: 80px;
            font-size: 0.95rem;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            appearance: none;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .value-display {
            font-variant-numeric: tabular-nums;
            width: 40px;
            text-align: right;
            font-weight: 500;
            color: var(--primary);
        }

        .hint {
            font-size: 0.85rem;
            color: var(--text-sub);
            margin-top: 10px;
            line-height: 1.4;
        }

        /* é¡µè„š */
        footer {
            padding: 20px;
            font-size: 0.8rem;
            color: #9ca3af;
            text-align: center;
        }

        a { color: inherit; text-decoration: none; }
    </style>
</head>
<body>

    <!-- å¯¼èˆªæ  -->
    <nav class="navbar">
        <h1 data-i18n="title">å°„çº¿æ¨¡æ‹Ÿå™¨</h1>
        <button class="lang-btn" id="langBtn" onclick="toggleLanguage()">
            <span id="langIcon">ğŸ‡ºğŸ‡¸</span> <span id="langText">English</span>
        </button>
    </nav>

    <!-- ä¸»å†…å®¹ -->
    <div class="container">
        
        <!-- ç”»å¸ƒ -->
        <div class="canvas-wrapper">
            <!-- é€»è¾‘åˆ†è¾¨ç‡è®¾ä¸º 800x800 ä»¥ä¿è¯é«˜æ¸…å±æ˜¾ç¤ºæ¸…æ™° -->
            <canvas id="canvas" width="800" height="800"></canvas>
        </div>

        <!-- æ§åˆ¶å™¨ -->
        <div class="controls">
            <div class="control-group">
                <label for="rotation" data-i18n="rotation">æ—‹è½¬</label>
                <input type="range" id="rotation" min="0" max="360" value="0">
                <span class="value-display" id="rotValue">0Â°</span>
            </div>
            <div class="hint" data-i18n="instruction">
                æ‹–æ‹½çº¢ç‚¹ç§»åŠ¨ä½ç½®ï¼Œæ»‘åŠ¨æ»‘å—æ—‹è½¬å°„çº¿ã€‚
            </div>
        </div>
    </div>

    <footer>
        <span data-i18n="footer">Created with HTML5 Canvas</span>
    </footer>

    <script>
        // --- å›½é™…åŒ–é…ç½® (i18n) ---
        const i18n = {
            zh: {
                title: "å°„çº¿äº¤äº’æ¨¡æ‹Ÿ",
                rotation: "æ—‹è½¬è§’åº¦",
                instruction: "ğŸ’¡ æ“ä½œæç¤ºï¼šæ‰‹æŒ‡/é¼ æ ‡æ‹–æ‹½çº¢ç‚¹ç§»åŠ¨ï¼Œä¸‹æ–¹æ»‘å—æ—‹è½¬å°„çº¿ã€‚",
                footer: "åŸºäº HTML5 Canvas åŸç”Ÿå¼€å‘",
                langBtn: "English",
                langIcon: "ğŸ‡ºğŸ‡¸",
                pointLabel: "Bç‚¹"
            },
            en: {
                title: "Ray Casting Sim",
                rotation: "Rotation",
                instruction: "ğŸ’¡ Tip: Drag the red point to move. Use slider to rotate rays.",
                footer: "Built with Vanilla HTML5 Canvas",
                langBtn: "ä¸­æ–‡",
                langIcon: "ğŸ‡¨ğŸ‡³",
                pointLabel: "Point B"
            }
        };

        let currentLang = 'zh'; // é»˜è®¤è¯­è¨€

        // --- ç³»ç»ŸçŠ¶æ€ ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const rotInput = document.getElementById('rotation');
        const rotValue = document.getElementById('rotValue');

        // ç”»å¸ƒé€»è¾‘å¤§å° (ä¸HTML widthå±æ€§ä¸€è‡´)
        const LOGICAL_SIZE = 800; 
        const RAY_COUNT = 8;
        
        let state = {
            bx: LOGICAL_SIZE / 2,
            by: LOGICAL_SIZE / 2,
            rotation: 0,
            isDragging: false
        };

        // --- æ ¸å¿ƒåŠŸèƒ½ ---

        function init() {
            // è‡ªåŠ¨æ£€æµ‹æµè§ˆå™¨è¯­è¨€
            const browserLang = navigator.language || navigator.userLanguage; 
            if (browserLang.toLowerCase().startsWith('en')) {
                setLanguage('en');
            } else {
                setLanguage('zh');
            }

            // äº‹ä»¶ç›‘å¬
            rotInput.addEventListener('input', (e) => {
                state.rotation = parseInt(e.target.value);
                rotValue.textContent = state.rotation + 'Â°';
                draw();
            });

            // é¼ æ ‡/è§¦æ‘¸äº‹ä»¶ (æ”¯æŒå¤šç«¯)
            addInputListeners();

            draw();
        }

        function setLanguage(lang) {
            currentLang = lang;
            const texts = i18n[lang];
            
            // æ›´æ–° DOM æ–‡æœ¬
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (texts[key]) el.textContent = texts[key];
            });

            // æ›´æ–°æŒ‰é’®
            document.getElementById('langText').textContent = texts.langBtn;
            document.getElementById('langIcon').textContent = texts.langIcon;
            
            // é‡ç»˜ Canvas (å› ä¸ºé‡Œé¢çš„æ–‡å­—ä¹Ÿè¦å˜)
            draw();
        }

        function toggleLanguage() {
            setLanguage(currentLang === 'zh' ? 'en' : 'zh');
        }

        // --- ç‰©ç†ä¸ç»˜å›¾ ---

        function getRayLength(x, y, angleRad) {
            let angle = angleRad % (Math.PI * 2);
            if (angle < 0) angle += Math.PI * 2;

            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            let distX = Infinity;
            let distY = Infinity;

            // å‚ç›´å¢™å£ (x=0, x=LOGICAL_SIZE)
            if (Math.abs(cos) > 1e-10) {
                distX = (cos > 0 ? LOGICAL_SIZE - x : -x) / cos;
            }

            // æ°´å¹³å¢™å£ (y=0, y=LOGICAL_SIZE)
            if (Math.abs(sin) > 1e-10) {
                distY = (sin > 0 ? LOGICAL_SIZE - y : -y) / sin;
            }

            return Math.min(distX, distY);
        }

        function draw() {
            // æ¸…ç©º
            ctx.clearRect(0, 0, LOGICAL_SIZE, LOGICAL_SIZE);

            // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
            drawGrid();

            const baseRad = state.rotation * Math.PI / 180;
            const stepRad = (Math.PI * 2) / RAY_COUNT;

            // å­—ä½“è®¾ç½®
            ctx.font = '24px Arial'; // é…åˆ800pxåˆ†è¾¨ç‡æ”¾å¤§å­—ä½“
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // ç»˜åˆ¶å°„çº¿
            for (let i = 0; i < RAY_COUNT; i++) {
                const angle = baseRad + i * stepRad;
                const dist = getRayLength(state.bx, state.by, angle);

                const endX = state.bx + Math.cos(angle) * dist;
                const endY = state.by + Math.sin(angle) * dist;

                // çº¿
                ctx.beginPath();
                ctx.moveTo(state.bx, state.by);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 4; // åŠ ç²—
                ctx.stroke();

                // äº¤ç‚¹
                ctx.beginPath();
                ctx.arc(endX, endY, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#1d4ed8';
                ctx.fill();

                // é•¿åº¦æ•°å€¼
                const textDist = Math.min(dist - 40, dist * 0.7);
                if (textDist > 20) {
                    const tx = state.bx + Math.cos(angle) * textDist;
                    const ty = state.by + Math.sin(angle) * textDist;
                    
                    const text = Math.round(dist).toString();
                    const metrics = ctx.measureText(text);
                    const padding = 10;
                    
                    // æ–‡å­—èƒŒæ™¯
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                    ctx.beginPath();
                    ctx.roundRect(
                        tx - metrics.width/2 - padding, 
                        ty - 16, 
                        metrics.width + padding*2, 
                        32, 
                        8
                    );
                    ctx.fill();
                    
                    ctx.fillStyle = '#000';
                    ctx.fillText(text, tx, ty);
                }
            }

            // ç»˜åˆ¶ä¸­å¿ƒ B ç‚¹
            ctx.beginPath();
            ctx.arc(state.bx, state.by, 16, 0, Math.PI * 2);
            ctx.fillStyle = '#ef4444';
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.stroke();

            // Bç‚¹æ ‡ç­¾
            ctx.fillStyle = '#333';
            ctx.font = 'bold 28px Arial';
            ctx.fillText(i18n[currentLang].pointLabel, state.bx, state.by - 35);
        }

        function drawGrid() {
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 2;
            const step = 100;
            ctx.beginPath();
            for (let i = step; i < LOGICAL_SIZE; i += step) {
                ctx.moveTo(i, 0); ctx.lineTo(i, LOGICAL_SIZE);
                ctx.moveTo(0, i); ctx.lineTo(LOGICAL_SIZE, i);
            }
            ctx.stroke();
        }

        // --- å“åº”å¼è¾“å…¥å¤„ç† (å…³é”®) ---

        function addInputListeners() {
            // é¼ æ ‡
            canvas.addEventListener('mousedown', handleStart);
            window.addEventListener('mousemove', handleMove);
            window.addEventListener('mouseup', handleEnd);

            // è§¦æ‘¸ (passive: false å…è®¸ preventDefault)
            canvas.addEventListener('touchstart', handleStart, {passive: false});
            window.addEventListener('touchmove', handleMove, {passive: false});
            window.addEventListener('touchend', handleEnd);
        }

        function getEventPos(e) {
            // è·å– Canvas åœ¨å±å¹•ä¸Šçš„çœŸå®å°ºå¯¸å’Œä½ç½®
            const rect = canvas.getBoundingClientRect();
            
            // è·å–è§¦ç‚¹æˆ–é¼ æ ‡ä½ç½®
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ (é€»è¾‘åˆ†è¾¨ç‡ / æ˜¾ç¤ºåˆ†è¾¨ç‡)
            const scaleX = LOGICAL_SIZE / rect.width;
            const scaleY = LOGICAL_SIZE / rect.height;

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function handleStart(e) {
            const pos = getEventPos(e);
            // æ£€æµ‹ç‚¹å‡»æ˜¯å¦åœ¨ B ç‚¹é™„è¿‘ (åŠå¾„æ”¾å®½æ–¹ä¾¿è§¦æ‘¸)
            const dx = pos.x - state.bx;
            const dy = pos.y - state.by;
            if (dx * dx + dy * dy < 2500) { // 50*50
                state.isDragging = true;
                e.preventDefault(); // é˜»æ­¢æ»šåŠ¨
            }
        }

        function handleMove(e) {
            if (!state.isDragging) return;
            e.preventDefault(); // æ‹–åŠ¨æ—¶å®Œå…¨ç¦æ­¢é¡µé¢æ»šåŠ¨

            const pos = getEventPos(e);
            
            // è¾¹ç•Œé™åˆ¶
            const padding = 20;
            state.bx = Math.max(padding, Math.min(LOGICAL_SIZE - padding, pos.x));
            state.by = Math.max(padding, Math.min(LOGICAL_SIZE - padding, pos.y));
            
            draw();
        }

        function handleEnd() {
            state.isDragging = false;
        }

        // å¯åŠ¨
        init();

    </script>
</body>
</html>